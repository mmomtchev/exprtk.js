--- exprtk/exprtk.hpp.orig	2024-01-01 01:00:00
+++ exprtk/exprtk.hpp	2025-11-14 20:01:19
@@ -54,6 +54,7 @@
 #include <string>
 #include <utility>
 #include <vector>
+#include <limits>
 
 
 namespace exprtk
@@ -89,6 +90,26 @@
       #endif
    #endif
 
+   template <typename T> struct type_traits {
+     const T max_vector_size = type_traits<T>::max_vector_size;
+   };
+
+   template <> struct type_traits<int16_t> {
+     static constexpr uint16_t max_vector_size = std::numeric_limits<int16_t>::max();
+   };
+
+   template <> struct type_traits<uint16_t> {
+     static constexpr uint16_t max_vector_size = std::numeric_limits<uint16_t>::max();
+   };
+
+   template <> struct type_traits<int8_t> {
+     static constexpr int8_t max_vector_size = std::numeric_limits<int8_t>::max();
+   };
+
+   template <> struct type_traits<uint8_t> {
+     static constexpr uint8_t max_vector_size = std::numeric_limits<uint8_t>::max();
+   };
+
    namespace details
    {
       typedef char                   char_t;
@@ -846,6 +867,8 @@
             exprtk_register_real_type_tag(double     )
             exprtk_register_real_type_tag(long double)
 
+            exprtk_register_int_type_tag(signed char   )
+            exprtk_register_int_type_tag(unsigned char )
             exprtk_register_int_type_tag(short         )
             exprtk_register_int_type_tag(int           )
             exprtk_register_int_type_tag(_int64_t      )
@@ -882,24 +905,48 @@
             }
 
             template <typename T>
+            inline bool is_nan_impl(const T, int_type_tag)
+            {
+               return false;
+            }
+
+            template <typename T>
             inline int to_int32_impl(const T v, real_type_tag)
             {
                return static_cast<int>(v);
             }
 
             template <typename T>
+            inline int to_int32_impl(const T v, int_type_tag)
+            {
+               return static_cast<int>(v);
+            }
+
+            template <typename T>
             inline _int64_t to_int64_impl(const T v, real_type_tag)
             {
                return static_cast<_int64_t>(v);
             }
 
             template <typename T>
+            inline _int64_t to_int64_impl(const T v, int_type_tag)
+            {
+               return static_cast<_int64_t>(v);
+            }
+
+            template <typename T>
             inline _uint64_t to_uint64_impl(const T v, real_type_tag)
             {
                return static_cast<_uint64_t>(v);
             }
 
             template <typename T>
+            inline _uint64_t to_uint64_impl(const T v, int_type_tag)
+            {
+               return static_cast<_uint64_t>(v);
+            }
+
+            template <typename T>
             inline bool is_true_impl(const T v)
             {
                return std::not_equal_to<T>()(T(0),v);
@@ -961,7 +1008,7 @@
             template <typename T>
             inline T expm1_impl(const T v, int_type_tag)
             {
-               return T(std::exp<double>(v)) - T(1);
+               return T(std::exp(v)) - T(1);
             }
 
             template <typename T>
@@ -1423,6 +1470,10 @@
             template <typename T> inline T  sqrt_impl(const T v, int_type_tag) { return std::sqrt (v); }
             template <typename T> inline T  frac_impl(const T  , int_type_tag) { return T(0);          }
             template <typename T> inline T trunc_impl(const T v, int_type_tag) { return v;             }
+            template <typename T> inline T   d2g_impl(const T  , int_type_tag) { return std::numeric_limits<T>::quiet_NaN(); }
+            template <typename T> inline T   g2d_impl(const T  , int_type_tag) { return std::numeric_limits<T>::quiet_NaN(); }
+            template <typename T> inline T   r2d_impl(const T  , int_type_tag) { return std::numeric_limits<T>::quiet_NaN(); }
+            template <typename T> inline T   d2r_impl(const T  , int_type_tag) { return std::numeric_limits<T>::quiet_NaN(); }
             template <typename T> inline T  acos_impl(const T  , int_type_tag) { return std::numeric_limits<T>::quiet_NaN(); }
             template <typename T> inline T acosh_impl(const T  , int_type_tag) { return std::numeric_limits<T>::quiet_NaN(); }
             template <typename T> inline T  asin_impl(const T  , int_type_tag) { return std::numeric_limits<T>::quiet_NaN(); }
@@ -2086,6 +2137,59 @@
          return true;
       }
 
+      template <typename Iterator, typename T>
+      inline bool string_to_real(Iterator& itr_external, const Iterator end, T& t, numeric::details::int_type_tag)
+      {
+         if (end == itr_external) return false;
+
+         Iterator itr = itr_external;
+
+         T d = T(0);
+
+         const bool negative = ('-' == (*itr));
+
+         if (negative || '+' == (*itr))
+         {
+            if (end == ++itr)
+               return false;
+         }
+
+         bool instate = false;
+
+         static const char_t zero = static_cast<uchar_t>('0');
+
+         #define parse_digit_1(d)          \
+         if ((digit = (*itr - zero)) < 10) \
+            { d = d * T(10) + digit; }     \
+         else                              \
+            { break; }                     \
+         if (end == ++itr) break;          \
+
+         #define parse_digit_2(d)          \
+         if ((digit = (*itr - zero)) < 10) \
+            { d = d * T(10) + digit; }     \
+         else                              \
+            { break; }                     \
+            ++itr;                         \
+
+         const Iterator curr = itr;
+
+         while ((end != itr) && (zero == (*itr))) ++itr;
+
+         while (end != itr)
+         {
+            unsigned int digit;
+            parse_digit_1(d)
+            parse_digit_1(d)
+            parse_digit_2(d)
+         }
+
+         if (curr != itr) instate = true;
+
+         t = static_cast<T>((negative) ? -d : d);
+         return instate;
+      }
+
       template <typename T>
       inline bool string_to_real(const std::string& s, T& t)
       {
@@ -5198,6 +5302,26 @@
       inline void dump_vector(const std::string&, const T*, const std::size_t) {}
       #endif
 
+      inline bool is_true(const unsigned int v)
+      {
+         return v != 0;
+      }
+
+      inline bool is_true(const int v)
+      {
+         return v != 0;
+      }
+
+      inline bool is_true(const unsigned char v)
+      {
+         return v != 0;
+      }
+
+      inline bool is_true(const char v)
+      {
+         return v != 0;
+      }
+
       template <typename T>
       class vec_data_store
       {
